---
layout: post
title: "Minimal chat web app with Angular and Flask in less than 60 minutes"
date: 2019-10-09
---

# How to setup a minimal chat web app with Angular and Flask in less than 60 minutes.

All the code is available here :
https://github.com/flassinot/minichat

## Angular setup

First we need to setup Angular.

Install nodeenv to build a virtual environment isolated from the rest of your software (on Linux) :
sudo pip install nodeenv
(cf https://pypi.org/project/nodeenv/)

Setup the virtual env for your directory :
```
mkdir minichat
cd minichat
nodeenv env
```

Activate your virtual env :
```
. env/bin/activate
```
(deactivate_node to get out)

Then install Angular and its dependencies :
```
npm install @angular/cli
```

(Actually it's better to use yarn, but we won't install it here for the sake of brevity)


## Angular code

First initialize a new app :
```
ng new chat
```

Angular generates all kinds of stuff for us. Take a look at the files that it created. 
For more information, read the Tour Of Heroes tutorial on the Angular website : https://angular.io/tutorial

### The chat service

Angular works with components and services so next we have to implement a service for our app :
ng generate service chat

Modify chat-service.ts in src/app to add two operations : one to get messages and another one to send a message to the server :
```
import { Injectable } from '@angular/core';
import { Observable, throwError } from 'rxjs';
import { HttpClient } from '@angular/common/http';

import { Chat } from './chat'
import { Message } from './message'

const URL = "http://localhost:5000/messages";

@Injectable({
  providedIn: 'root'
})
export class ChatService {

  constructor(private http: HttpClient) { }

  getMessages(): Observable<Chat> {
    return this.http.get<Chat>(URL, {responseType: 'json'});
  }

  sendMessage(message: Message) {
    this.http
      .post(URL, message)
      .subscribe(
        () => {
          console.log('Enregistrement terminÃ© !');
        },
        (error) => {
          console.log('Erreur ! : ' + error);
        }
      );
  }
}
```

### HTML Template

Next, we have to display an interface to print messages and allow the user to type new messages :

Modify app.component.html :

```
<div class="header">
    <h1>MINI CHAT</h1>
</div>
<div class="flex-container">
    <div class="box infos">
        <p>Your name :</p>
        <input type="text" #name class="text">
    </div>
    <div class="box messages">
        <h2 style="text-align: center">Messages</h2>
        
        <div #messagesList id="messages-list" class="messages-list">
            <div *ngFor="let message of messages">
                <p>{{message.nom}} says : {{message.message}}</p>
            </div>
        </div>
        <div>
            <p>Type your message here :</p>
            <textarea #messagetext rows="4" cols="50"></textarea>

            <button type="submit" (click)="send(name.value, messagetext.value)">Send</button>
        </div>
    </div>
  </div> 
```

Here we add a div element containing our list of messages (#messagesList). The app iterates on the list using ngFor.
A textarea is used to allow the user to post a message (#messagetext) and the message is send by calling the send method.
Nothing very complicated so far.

Adding a few css rules makes our interface more readable. Modify app.component.css :
```
.header {
  padding: 60px;
  text-align: center;
  background: #17914a;
  color: white;
  padding: 0px;
}

.flex-container {
  display: flex;
  justify-content: space-around;
}

.messages-list {
  height: 300px;
  overflow:auto;
}

div.box {
  border: 1px solid grey;
  box-shadow: 0 20px 5px rgba(59, 43, 91, 0.7);
  padding: 10px;
  font-family: arial;
}

div.infos {
  flex-grow: 1
}

div.messages {
  flex-grow: 2
}
```


### Angular Component

Components are the glue that make the elements of an Angular app work together.
We need to get a list of messages and display them in the html template regularly. Second we need to make the component read the user input and send it to our service.

The app will use the service in the default component created by ng generate.
Note : we will use only one component in this tutorial, but you should make a separate component for every part of your app (user info, messages input etc.)

Modify app.component.ts :

```
import { Component, ViewChild, ElementRef } from '@angular/core';
import { ChatService } from './chat-service';
import { Message } from './message';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {

  @ViewChild('messagesList', {static : false}) messagesList: ElementRef;
  messages: Object[];

  constructor(private chatService: ChatService) {
    this.messages = [];
  }

  ngOnInit() {
    setInterval(() =>
      this.chatService.getMessages().subscribe((value) => {
        this.messages = value.messages;
        this.messagesList.nativeElement.scrollTop = this.messagesList.nativeElement.scrollHeight + 100;
      }),
      1000);
  }

  send(name: string, text: string) {
    let message: Message = new Message();

    message.name = name;
    message.message = text;
    message.date = (new Date()).toISOString();
    this.chatService.sendMessage(message);
  }
}
```

Here setInterval calls our chatService (getMessages) to get messages and apply the result to our messageList.
Send takes a the user name and a text as parameters and sends it to our chatService vie sendMessage.

Go to the front folder and launch the front-end with ng :
```
ng serve
```


## Setup Flask / Python

First setup a virtual environment for the Flask app :
```
python3 -m venv venv-p3
```

Activate your virtual env :
```
source venv-p3/bin/activate
```
(deactivate to get out)

Install Flask and the CORS library (for local development) :
```
pip3 install flask_cors
```


## Python code

We will use Sqlite3 as it is the easiest database to setup in Python.
First we need a database and a simple table for our app. Create a file called create_db.py :

```
import sqlite3

conn = sqlite3.connect('database.db')
print("Opened database successfully");

conn.execute('CREATE TABLE messages (name TEXT, message TEXT, date timestamp)')
print("Table created successfully");
conn.close()

Then execute it :
python3 create_db.py
```


Let's insert a few messages. Create a file named insert_messages.py :
```
import sqlite3

conn = sqlite3.connect('database.db')
print("Opened database successfully");

conn.execute('DELETE FROM messages')
conn.execute('INSERT INTO messages VALUES (\'Henri\', \'Welcome\', \'2019-06-28 21:12:35.799206\')')
conn.execute('INSERT INTO messages VALUES (\'Tommy\', \'I did NOT it her. I did NOT. Oh Hi mark !\', \'2019-06-28 21:20:00.800000\')')
conn.commit()
print("Insert successfull");
conn.close()
```

and execute it :
```
python3 insert_messages.py
```

Now we have a table with messages. Let's access this information with Flask.

Create db_access.py :

```
import sqlite3 as sql

FETCH_SIZE = 10

def list_messages():
    """ List all messages """

    result = []

    with sql.connect("database.db") as con:
        con.row_factory = sql.Row

        cur = con.cursor()
        cur.execute("SELECT * FROM messages ORDER BY date DESC")
        records = cur.fetchmany(FETCH_SIZE)

        for row in records:
            result.insert(0, {'nom':row[0], 'message':row[1], 'date':row[2]})

    return result

def save_message(name, message, date):
    """ Save a message """

    with sql.connect("database.db") as con:
        cur = con.cursor()

        cur.execute("INSERT INTO messages (name,message,date) VALUES (?,?,?)",(name, message, date) )

        con.commit()
        msg = "Record successfully added"
```

As you can see the code is pretty simple.
List_messages reads from the table as its name suggests and returns a dictionary containing the message info. The function returns only the last 10 messages with fetchmany(FETCH_SIZE) so we don't send every message to every client for each request.
Save_message takes three parameters as info to insert a new message into the database.

To send this information via REST operations back and forth between the front and the back, create a file called chat.py (our main file) :

```
from flask import Flask, escape, url_for, request, render_template
from flask_cors import CORS

from db_access import list_messages, save_message

app = Flask(__name__)
CORS(app)

@app.route('/chat/')
def hello():
    return render_template('chat.html')

@app.route('/messages', methods = ['POST'])
def addmessage():

    json = request.json
    name = json['name']
    message = json['message']
    date = json['date']

    save_message(name, message, date)

    return ""

@app.route("/messages", methods = ['GET'])
def messages():

    messages_list = list_messages()

    return {
        "messages": messages_list
    }
```

Finally launch the back-end :
```
export FLASK_ENV=development && env FLASK_APP=chat.py flask run --reload --debugger
```



